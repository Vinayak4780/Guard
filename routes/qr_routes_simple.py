"""
Simplified QR Code routes - Essential QR management only
Only includes:
1. Automatic QR generation by supervisor
2. QR scan by guard
"""

from fastapi import APIRouter, HTTPException, status, Depends
from typing import Dict, Any
import logging
from bson import ObjectId
import qrcode
import io
import base64
from datetime import datetime, timezone, timedelta

# Import services and dependencies
from services.auth_service import get_current_supervisor
from database import get_qr_locations_collection, get_scan_events_collection
from config import settings

logger = logging.getLogger(__name__)

# Create router
qr_router = APIRouter()


# ============================================================================
# SUPERVISOR ENDPOINTS - Automatic QR Generation
# ============================================================================

@qr_router.post("/create-auto")
async def create_automatic_qr(
    current_supervisor: Dict[str, Any] = Depends(get_current_supervisor)
):
    """
    SUPERVISOR ONLY: Create QR location automatically
    No parameters needed - uses supervisor's area information
    """
    try:
        qr_locations_collection = get_qr_locations_collection()
        
        if not qr_locations_collection:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Database not available"
            )
        
        supervisor_id = current_supervisor["_id"]
        supervisor_area = current_supervisor.get("areaCity", "Unknown")
        supervisor_name = current_supervisor.get("name", "Supervisor")
        
        # Auto-generate label from supervisor area
        auto_label = f"{supervisor_area} Patrol Point"
        
        # Check if QR location already exists
        existing_qr = await qr_locations_collection.find_one({"supervisorId": supervisor_id})
        
        if existing_qr:
            return {
                "message": "QR location already exists for this supervisor",
                "qr_id": str(existing_qr["_id"]),
                "label": existing_qr.get("label", auto_label),
                "supervisor_area": supervisor_area,
                "coordinates": {
                    "lat": existing_qr.get("lat", 0.0),
                    "lng": existing_qr.get("lng", 0.0),
                    "note": "Location automatically updated when guards scan"
                },
                "existing": True
            }
        
        # Create new QR location automatically
        qr_location_data = {
            "supervisorId": supervisor_id,
            "supervisorArea": supervisor_area,
            "supervisorName": supervisor_name,
            "label": auto_label,
            "lat": 0.0,  # Will be updated when first guard scans
            "lng": 0.0,  # Will be updated when first guard scans
            "active": True,
            "autoGenerated": True,
            "createdAt": datetime.utcnow(),
            "updatedAt": datetime.utcnow()
        }
        
        result = await qr_locations_collection.insert_one(qr_location_data)
        qr_id = str(result.inserted_id)
        
        return {
            "message": "QR location created automatically",
            "qr_id": qr_id,
            "label": auto_label,
            "supervisor_area": supervisor_area,
            "supervisor_name": supervisor_name,
            "coordinates": {
                "lat": 0.0,
                "lng": 0.0,
                "note": "Location will be set automatically when first guard scans this QR"
            },
            "auto_generated": True,
            "instructions": "Print this QR code and place it at your patrol location. Coordinates will be captured automatically when guards scan it."
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error creating automatic QR: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create automatic QR location"
        )


@qr_router.get("/generate/{qr_id}")
async def generate_qr_code(
    qr_id: str,
    current_supervisor: Dict[str, Any] = Depends(get_current_supervisor)
):
    """
    SUPERVISOR ONLY: Generate QR code image optimized for mobile camera scanning
    """
    try:
        # Verify QR belongs to this supervisor
        qr_locations_collection = get_qr_locations_collection()
        qr_location = await qr_locations_collection.find_one({
            "_id": ObjectId(qr_id),
            "supervisorId": current_supervisor["_id"]
        })
        
        if not qr_location:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="QR location not found or not authorized"
            )
        
        # Simple QR content - just the QR ID for easy camera scanning
        qr_content = f"GUARD_QR_{qr_id}"
        
        # Generate QR code optimized for mobile scanning
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_M,  # Medium error correction for better scanning
            box_size=12,  # Larger box size for better camera recognition
            border=4,
        )
        qr.add_data(qr_content)
        qr.make(fit=True)
        
        # Create QR code image with high contrast for better mobile scanning
        img = qr.make_image(fill_color="black", back_color="white")
        
        # Convert to base64
        img_buffer = io.BytesIO()
        img.save(img_buffer, format='PNG')
        img_str = base64.b64encode(img_buffer.getvalue()).decode()
        
        return {
            "qr_id": qr_id,
            "qr_content": qr_content,
            "qr_code": f"data:image/png;base64,{img_str}",
            "label": qr_location.get("label", "Patrol Point"),
            "supervisor_area": qr_location.get("supervisorArea", "Unknown"),
            "scan_format": "Mobile app should extract ID and use current GPS location",
            "message": "QR code generated for camera scanning"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error generating QR code: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to generate QR code"
        )


@qr_router.get("/my-location")
async def get_my_qr_location(
    current_supervisor: Dict[str, Any] = Depends(get_current_supervisor)
):
    """
    SUPERVISOR ONLY: Get QR location for current supervisor
    """
    try:
        qr_locations_collection = get_qr_locations_collection()
        
        if not qr_locations_collection:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Database not available"
            )
        
        supervisor_id = current_supervisor["_id"]
        
        # Get QR location for this supervisor
        qr_location = await qr_locations_collection.find_one({"supervisorId": supervisor_id})
        
        if not qr_location:
            return {
                "message": "No QR location found. Create one using /create-auto endpoint",
                "qr_location": None,
                "has_qr": False
            }
        
        response_data = {
            **qr_location,
            "_id": str(qr_location["_id"]),
            "has_qr": True
        }
        
        return {"qr_location": response_data}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting QR location: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get QR location"
        )


# ============================================================================
# GUARD ENDPOINTS - QR Scanning Only
# ============================================================================

@qr_router.post("/scan")
async def scan_qr_code(
    scanned_content: str,
    guard_email: str,
    device_lat: float,
    device_lng: float
):
    """
    GUARD ONLY: Camera QR scanning endpoint
    Optimized for mobile apps - automatically extracts QR ID from scanned content
    """
    try:
        from services.google_drive_excel_service import google_drive_excel_service
        
        scan_events_collection = get_scan_events_collection()
        qr_locations_collection = get_qr_locations_collection()
        
        if not all([scan_events_collection, qr_locations_collection]):
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Database not available"
            )
        
        # Extract QR ID from scanned content (handle different formats)
        qr_id = scanned_content.strip()
        
        # Handle different QR content formats
        if qr_id.startswith("GUARD_QR_"):
            actual_qr_id = qr_id.replace("GUARD_QR_", "")
        elif qr_id.startswith("QR_"):
            actual_qr_id = qr_id.replace("QR_", "")
        elif len(qr_id) == 24:  # MongoDB ObjectId length
            actual_qr_id = qr_id
        else:
            # Try to extract ObjectId pattern
            import re
            object_id_match = re.search(r'([a-f0-9]{24})', qr_id)
            if object_id_match:
                actual_qr_id = object_id_match.group(1)
            else:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Invalid QR code format: {scanned_content}"
                )
        
        # Validate QR code exists
        try:
            qr_location = await qr_locations_collection.find_one({"_id": ObjectId(actual_qr_id)})
        except:
            qr_location = None
        
        if not qr_location:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"QR code not found: {actual_qr_id}"
            )
        
        if not qr_location.get("active", True):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="QR code is inactive"
            )
        
        # Update QR location coordinates if they are default (0,0) - first scan
        location_updated = False
        if qr_location.get("lat", 0) == 0.0 and qr_location.get("lng", 0) == 0.0:
            await qr_locations_collection.update_one(
                {"_id": ObjectId(actual_qr_id)},
                {
                    "$set": {
                        "lat": device_lat,
                        "lng": device_lng,
                        "updatedAt": datetime.utcnow(),
                        "firstScanUpdate": True
                    }
                }
            )
            location_updated = True
            logger.info(f"Updated QR location {actual_qr_id} with coordinates from first scan")
        
        # Create scan event
        scanned_at = datetime.utcnow()
        
        # Convert to IST for Excel
        ist_timezone = timezone(timedelta(hours=5, minutes=30))
        scanned_at_ist = scanned_at.astimezone(ist_timezone)
        timestamp_ist = scanned_at_ist.strftime("%d-%m-%Y %H:%M:%S")
        
        scan_event = {
            "qrId": actual_qr_id,
            "originalScanContent": scanned_content,
            "guardEmail": guard_email,
            "deviceLat": device_lat,
            "deviceLng": device_lng,
            "scannedAt": scanned_at,
            "createdAt": datetime.utcnow(),
            "timestampIST": timestamp_ist,
            "locationUpdated": location_updated
        }
        
        # Insert scan event
        result = await scan_events_collection.insert_one(scan_event)
        scan_event["_id"] = str(result.inserted_id)
        
        # Log to Google Drive Excel
        try:
            scan_data_for_excel = {
                "timestamp": timestamp_ist,
                "date": timestamp_ist.split(' ')[0] if ' ' in timestamp_ist else timestamp_ist,
                "time": timestamp_ist.split(' ')[1] if ' ' in timestamp_ist else "00:00:00",
                "guard_name": guard_email.split('@')[0],  # Extract name from email
                "guard_email": guard_email,
                "employee_code": "",
                "supervisor_name": qr_location.get("supervisorName", "Supervisor"),
                "supervisor_area": qr_location.get("supervisorArea", "Unknown"),
                "area_city": qr_location.get("supervisorArea", "Unknown"),
                "qr_location": qr_location.get("label", f"QR {actual_qr_id}"),
                "latitude": device_lat,
                "longitude": device_lng,
                "distance_meters": 0.0,
                "status": "SUCCESS",
                "address": "Address not available",
                "landmark": "",
                "remarks": f"Camera scan {('(First scan - location set)' if location_updated else '')}"
            }
            
            await google_drive_excel_service.add_scan_to_queue(scan_data_for_excel)
            
        except Exception as e:
            logger.error(f"Failed to log to Excel: {e}")
        
        logger.info(f"QR scan: {guard_email} scanned {scanned_content} -> {actual_qr_id}")
        
        return {
            "message": "QR code scanned successfully",
            "scan_id": scan_event["_id"],
            "timestamp": timestamp_ist,
            "qr_id": actual_qr_id,
            "qr_label": qr_location.get("label", "Patrol Point"),
            "supervisor_area": qr_location.get("supervisorArea", "Unknown"),
            "location_updated": location_updated,
            "coordinates": {
                "scanned_lat": device_lat,
                "scanned_lng": device_lng
            },
            "note": "QR location coordinates updated from your GPS" if location_updated else "Scan recorded successfully"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error processing QR scan: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to process QR scan"
        )


@qr_router.get("/validate/{qr_content}")
async def validate_qr_code(qr_content: str):
    """
    GUARD ONLY: Validate QR code content before scanning
    For mobile app QR preview - check if QR is valid before actual scan
    """
    try:
        qr_locations_collection = get_qr_locations_collection()
        
        if not qr_locations_collection:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Database not available"
            )
        
        # Extract QR ID
        qr_id = qr_content.strip()
        if qr_id.startswith("GUARD_QR_"):
            actual_qr_id = qr_id.replace("GUARD_QR_", "")
        elif qr_id.startswith("QR_"):
            actual_qr_id = qr_id.replace("QR_", "")
        else:
            actual_qr_id = qr_id
        
        # Check if QR exists
        try:
            qr_location = await qr_locations_collection.find_one({"_id": ObjectId(actual_qr_id)})
        except:
            qr_location = None
        
        if qr_location and qr_location.get("active", True):
            return {
                "valid": True,
                "qr_id": actual_qr_id,
                "label": qr_location.get("label", "Patrol Point"),
                "supervisor_area": qr_location.get("supervisorArea", "Unknown"),
                "supervisor_name": qr_location.get("supervisorName", "Supervisor"),
                "coordinates": {
                    "lat": qr_location.get("lat", 0.0),
                    "lng": qr_location.get("lng", 0.0)
                },
                "is_first_scan": qr_location.get("lat", 0.0) == 0.0,
                "message": "Valid QR code - ready to scan"
            }
        else:
            return {
                "valid": False,
                "message": "Invalid or inactive QR code",
                "qr_content": qr_content
            }
            
    except Exception as e:
        logger.error(f"Error validating QR: {e}")
        return {
            "valid": False,
            "message": "Error validating QR code",
            "error": str(e)
        }
